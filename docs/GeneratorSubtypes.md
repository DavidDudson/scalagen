# Generators


## Extension Generators

When you want to extend the functionality of a class/trait/object, *without* affecting existing code.

### Signature

```
A => List[Stat]
```

### Supported Tree's

- Defn.Object
- Defn.Trait
- Defn.Class

### Examples
- *case* class like behaviour.
  - Generated toString/hashCode etc.
- Autogenerated Java Api's for scala classes.
  - Generate get methods for every property
  - Generate methods with the correct method types
  - Generate methods that are not callable from Java

**Before**
```scala
@CaseInsensitiveEquals
case class Id(str: String)
```

**After**
```scala
case class Id(str: String) {
  def equals(other: Any): Boolean = {
    other match {
       case Id(otherStr) => str.equalsIgnoreCase(otherStr)
       case _ => fasle
    }
  }
}
```

## Companion Extension Generator

Almost identical to the Extension Generator
- Stats are added to the Companion, not the defintion
- If a Companion does not exist, it will be created

### Signature

```
A => List[Stat]
```

### Supported Tree's

- Defn.Type
- Defn.Trait
- Defn.Class

### Examples

- Generate apply/unapply
- Typeclass derivation

**Before**

```scala
@Deriving[Eq]
case class Point(x: Int, y: Int)
```

**After**
```scala
case class Point(x: Int, y: Int)

object Point {
  implicit val eq: Eq[Point] = new Eq[Point] {
    def eqv(a: Point, b: Point): Boolean = a == b
  }
}
```

## Manipulation Generator

Completely transform the input into a new Tree of the same type

## Signature
```
A => A
```

### Supported Tree's

- Defn.Object
- Defn.Trait
- Defn.Class
- Defn.Type
- Defn.Def
- Defn.Val
- Defn.Var

### Examples

- Decorate a method
- Alter the entire structure of an object `@free` `@typeclass`

**Before**

```scala
@PrintTime
def sum(ints: List[Int]): Int = ints.sum
```

**After**

```scala
def sum(ints: List[Int]): Int = {
  val start = System.currentTimeMillis
  val res = ints.sum
  val end = System.currentTimeMillis
  res
}
```

## Transmutation Generator

Black magic.

This adds the capability to generate *siblings*.

Aka, add children to the anotee's parent.

## Signature
```
A => List[Defn]
```

### Supported Tree's

- Defn.Object
- Defn.Trait
- Defn.Class
- Defn.Type
- Defn.Def
- Defn.Val
- Defn.Var

### Examples
- `@free` and `@typeclass` could both port to this structure
- Add methods callable from java for scala centric methods.
- Add symbolic method names in an understandable way.

**Before**

```scala
case class Point(x: Int, y: Int) {
  @Op("+")
  def add(p: Point) = Point(p.x + x, p.y + y)
}
```

**After**

```scala
case class Point(x: Int, y: Int) {
  @inline def +(p:Point) = add(p)
  def add(p: Point) = Point(p.x + x, p.y + y)
}
```


Note: All examples given here are merely for demonstrating generators,
capabilities and are not necessarily perfect code
